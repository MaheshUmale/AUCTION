
ACCESS_TOKEN = 'eyJ0eXAiOiJKV1QiLCJrZXlfaWQiOiJza192MS4wIiwiYWxnIjoiSFMyNTYifQ.eyJzdWIiOiI3NkFGMzUiLCJqdGkiOiI2OTQwYjZhYWIwMTU5MjMwZjUyNzc5YTYiLCJpc011bHRpQ2xpZW50IjpmYWxzZSwiaXNQbHVzUGxhbiI6ZmFsc2UsImlhdCI6MTc2NTg0ODc0NiwiaXNzIjoidWRhcGktZ2F0ZXdheS1zZXJ2aWNlIiwiZXhwIjoxNzY1OTIyNDAwfQ.iClOpRDJFFX5UXsH5-8SOxFJzeKXB_S2jlLJyq6HmnI'

initial_instruments =["NSE_INDEX|Nifty 50", "NSE_INDEX|Nifty Bank","NSE_EQ|INE585B01010","NSE_EQ|INE139A01034","NSE_EQ|INE1NPP01017","NSE_EQ|INE917I01010","NSE_EQ|INE267A01025","NSE_EQ|INE466L01038","NSE_EQ|INE070A01015","NSE_EQ|INE749A01030","NSE_EQ|INE171Z01026","NSE_EQ|INE591G01025","NSE_EQ|INE160A01022","NSE_EQ|INE814H01029","NSE_EQ|INE102D01028","NSE_EQ|INE134E01011","NSE_EQ|INE009A01021","NSE_EQ|INE376G01013","NSE_EQ|INE619A01035","NSE_EQ|INE465A01025","NSE_EQ|INE540L01014","NSE_EQ|INE237A01028","NSE_EQ|INE361B01024","NSE_EQ|INE811K01011","NSE_EQ|INE01EA01019","NSE_EQ|INE030A01027","NSE_EQ|INE476A01022","NSE_EQ|INE721A01047","NSE_EQ|INE028A01039","NSE_EQ|INE670K01029","NSE_EQ|INE158A01026","NSE_EQ|INE123W01016","NSE_EQ|INE192A01025","NSE_EQ|INE118A01012","NSE_EQ|INE674K01013","NSE_EQ|INE094A01015","NSE_EQ|INE528G01035","NSE_EQ|INE093I01010","NSE_EQ|INE073K01018","NSE_EQ|INE006I01046","NSE_EQ|INE142M01025","NSE_EQ|INE169A01031","NSE_EQ|INE849A01020","NSE_EQ|INE669C01036","NSE_EQ|INE216A01030","NSE_EQ|INE111A01025","NSE_EQ|INE062A01020","NSE_EQ|INE081A01020","NSE_EQ|INE883A01011","NSE_EQ|INE075A01022","NSE_EQ|INE498L01015","NSE_EQ|INE377N01017","NSE_EQ|INE484J01027","NSE_EQ|INE205A01025","NSE_EQ|INE027H01010","NSE_EQ|INE121A01024","NSE_EQ|INE974X01010","NSE_EQ|INE854D01024","NSE_EQ|INE742F01042","NSE_EQ|INE226A01021","NSE_EQ|INE047A01021","NSE_EQ|INE326A01037","NSE_EQ|INE584A01023","NSE_EQ|INE414G01012","NSE_EQ|INE669E01016","NSE_EQ|INE211B01039","NSE_EQ|INE813H01021","NSE_EQ|INE213A01029","NSE_EQ|INE335Y01020","NSE_EQ|INE931S01010","NSE_EQ|INE704P01025","NSE_EQ|INE053F01010","NSE_EQ|INE127D01025","NSE_EQ|INE021A01026","NSE_EQ|INE356A01018","NSE_EQ|INE733E01010","NSE_EQ|INE115A01026","NSE_EQ|INE702C01027","NSE_EQ|INE388Y01029","NSE_EQ|INE117A01022","NSE_EQ|INE239A01024","NSE_EQ|INE437A01024","NSE_EQ|INE245A01021","NSE_EQ|INE053A01029","NSE_EQ|INE196A01026","NSE_EQ|INE121J01017","NSE_EQ|INE399L01023","NSE_EQ|INE121E01018","NSE_EQ|INE019A01038","NSE_EQ|INE151A01013","NSE_EQ|INE522F01014","NSE_EQ|INE296A01032","NSE_EQ|INE066F01020","NSE_EQ|INE002A01018","NSE_EQ|INE203G01027","NSE_EQ|INE467B01029","NSE_EQ|INE0ONG01011","NSE_EQ|INE079A01024","NSE_EQ|INE0J1Y01017","NSE_EQ|INE260B01028","NSE_EQ|INE040A01034","NSE_EQ|INE121A08PJ0","NSE_EQ|INE603J01030","NSE_EQ|INE202E01016","NSE_EQ|INE663F01032","NSE_EQ|INE066A01021","NSE_EQ|INE752E01010","NSE_EQ|INE271C01023","NSE_EQ|INE318A01026","NSE_EQ|INE918I01026","NSE_EQ|INE758E01017","NSE_EQ|INE089A01031","NSE_EQ|INE848E01016","NSE_EQ|INE982J01020","NSE_EQ|INE761H01022","NSE_EQ|INE494B01023","NSE_EQ|INE646L01027","NSE_EQ|INE0V6F01027","NSE_EQ|INE010B01027","NSE_EQ|INE302A01020","NSE_EQ|INE634S01028","NSE_EQ|INE397D01024","NSE_EQ|INE192R01011","NSE_EQ|INE775A08105","NSE_EQ|INE059A01026","NSE_EQ|INE377Y01014","NSE_EQ|INE343G01021","NSE_EQ|INE797F01020","NSE_EQ|INE180A01020","NSE_EQ|INE949L01017","NSE_EQ|INE881D01027","NSE_EQ|INE795G01014","NSE_EQ|INE280A01028","NSE_EQ|INE298A01020","NSE_EQ|INE155A01022","NSE_EQ|INE274J01014","NSE_EQ|INE012A01025","NSE_EQ|INE095A01012","NSE_EQ|INE562A01011","NSE_EQ|INE195A01028","NSE_EQ|INE118H01025","NSE_EQ|INE364U01010","NSE_EQ|INE238A01034","NSE_EQ|INE044A01036","NSE_EQ|INE379A01028","NSE_EQ|INE338I01027","NSE_EQ|INE935N01020","NSE_EQ|INE038A01020","NSE_EQ|INE031A01017","NSE_EQ|INE242A01010","NSE_EQ|INE692A01016","NSE_EQ|INE04I401011","NSE_EQ|INE061F01013","NSE_EQ|INE263A01024","NSE_EQ|INE020B01018","NSE_EQ|INE685A01028","NSE_EQ|INE647A01010","NSE_EQ|INE860A01027","NSE_EQ|INE0BS701011","NSE_EQ|INE00H001014","NSE_EQ|INE171A01029","NSE_EQ|INE262H01021","NSE_EQ|INE084A01016","NSE_EQ|INE775A01035","NSE_EQ|INE878B01027","NSE_EQ|INE018E01016","NSE_EQ|INE776C01039","NSE_EQ|INE417T01026","NSE_EQ|INE415G01027","NSE_EQ|INE821I01022","NSE_EQ|INE323A01026","NSE_EQ|INE214T01019","NSE_EQ|INE176B01034","NSE_EQ|INE249Z01020","NSE_EQ|INE343H01029","NSE_EQ|INE758T01015","NSE_EQ|INE154A01025","NSE_EQ|INE455K01017","NSE_EQ|INE406A01037","NSE_EQ|INE101A01026","NSE_EQ|INE208A01029","NSE_EQ|INE303R01014","NSE_EQ|INE090A01021","NSE_EQ|INE472A01039","NSE_EQ|INE628A01036","NSE_EQ|INE040H01021","NSE_EQ|INE018A01030","NSE_EQ|INE092T01019","NSE_EQ|INE067A01029","NSE_EQ|INE423A01024","NSE_EQ|INE259A01022","NSE_EQ|INE07Y701011","NSE_EQ|INE765G01017","NSE_EQ|INE257A01026","NSE_EQ|INE774D01024","NSE_EQ|INE129A01019","NSE_EQ|INE481G01011","NSE_EQ|INE114A01011","NSE_EQ|INE774D08MG3","NSE_EQ|INE935A01035","NSE_EQ|INE003A01024","NSE_EQ|INE029A01011","NSE_EQ|INE670A01012","NSE_EQ|INE200M01039","NSE_EQ|INE016A01026"]

NiftyFO = ["NSE_FO|41910","NSE_FO|41913","NSE_FO|41914","NSE_FO|41915","NSE_FO|41916","NSE_FO|41917","NSE_FO|41918","NSE_FO|41921","NSE_FO|41922","NSE_FO|41923","NSE_FO|41924","NSE_FO|41925","NSE_FO|41926","NSE_FO|41927","NSE_FO|41928","NSE_FO|41935","NSE_FO|41936","NSE_FO|41939","NSE_FO|41940","NSE_FO|41943","NSE_FO|41944","NSE_FO|41945","NSE_FO|41946"]
BN_FO =["NSE_FO|51414","NSE_FO|51415","NSE_FO|51416","NSE_FO|51417","NSE_FO|51420","NSE_FO|51421","NSE_FO|51439","NSE_FO|51440","NSE_FO|51460","NSE_FO|51461","NSE_FO|51475","NSE_FO|51476","NSE_FO|51493","NSE_FO|51498","NSE_FO|51499","NSE_FO|51500","NSE_FO|51501","NSE_FO|51502","NSE_FO|51507","NSE_FO|51510","NSE_FO|60166","NSE_FO|60167"]


# append all 3 arrays into one
all_instruments = initial_instruments + NiftyFO + BN_FO











# =====================================================
# Imports
# =====================================================

import asyncio
import json
import time
from datetime import datetime
from collections import defaultdict
import threading

from fastapi import FastAPI, WebSocket
from fastapi.staticfiles import StaticFiles
from fastapi.responses import JSONResponse

import uvicorn
from motor.motor_asyncio import AsyncIOMotorClient

import upstox_client
from upstox_client import MarketDataStreamerV3

# =====================================================
# CONFIG â€” EXACT, CONSISTENT
# =====================================================


MONGO_URI = "mongodb://localhost:27017"
DB_NAME = "market_fp"
COL_FOOTPRINT = "footprints"
COL_DOM = "dom"

FOOTPRINT_TF_SEC = 30
PORT = 8000

# MUST EXIST IN YOUR FILE
INSTRUMENTS = all_instruments

# =====================================================
# FASTAPI APP
# =====================================================

app = FastAPI()
clients: set[WebSocket] = set()

# =====================================================
# ASYNC QUEUE (SINGLE LOOP SAFE)
# =====================================================

market_queue: asyncio.Queue = asyncio.Queue()

# =====================================================
# MONGO (BOUND TO FASTAPI LOOP)
# =====================================================

mongo = AsyncIOMotorClient(MONGO_URI)
db = mongo[DB_NAME]
fp_col = db[COL_FOOTPRINT]
dom_col = db[COL_DOM]

# =====================================================
# BROADCAST
# =====================================================

async def broadcast(payload: dict):
    msg = json.dumps(payload, default=str)
    dead = []
    for ws in clients:
        try:
            await ws.send_text(msg)
        except:
            dead.append(ws)
    for ws in dead:
        clients.discard(ws)

# =====================================================
# FOOTPRINT ENGINE
# =====================================================

class FootprintEngine:
    def __init__(self, symbol: str):
        self.symbol = symbol
        self.reset()

    def reset(self):
        self.start_ts = int(time.time() // FOOTPRINT_TF_SEC * FOOTPRINT_TF_SEC)
        self.levels = defaultdict(lambda: {"bid": 0, "ask": 0})

    # async def on_tick(self, snap: dict):
    #     bidask = snap["bidask"]
    #     ltp = snap["ltp"]
    #     ltq = snap["ltq"]

    #     if bidask:
    #         if "bidP" in bidask:
    #             best_bid = bidask[0]["bidP"]
    #         else :
    #             best_bid =0

    #         if "askP" in bidask:
    #             best_ask = bidask[0]["askP"]
    #         else :
    #             best_ask=999999

    #         if best_ask and ltp >= best_ask:
    #             self.levels[ltp]["ask"] += ltq
    #         elif best_bid and ltp <= best_bid:
    #             self.levels[ltp]["bid"] += ltq

    #     now = int(time.time())
    #     if now - self.start_ts >= FOOTPRINT_TF_SEC:
    #         doc = {
    #             "symbol": self.symbol,
    #             "ts": self.start_ts,
    #             "levels": dict(self.levels),
    #             "created_at": datetime.utcnow()
    #         }
    #         await fp_col.insert_one(doc)
    #         await broadcast({"type": "footprint", **doc})
    #         self.reset()

    async def on_tick(self, snap: dict):
        bidask = snap.get("bidask", [])
        ltp = snap.get("ltp")
        ltq = snap.get("ltq", 0)

        if ltp is None:
            return

        # ALWAYS add LTP to levels
        if ltp not in self.levels:
            self.levels[ltp] = {"bid": 0, "ask": 0}

        if bidask:
            best_bid = bidask[0].get("bidP")
            best_ask = bidask[0].get("askP")

            if best_bid is not None and ltp <= best_bid:
                self.levels[ltp]["bid"] += ltq
            elif best_ask is not None and ltp >= best_ask:
                self.levels[ltp]["ask"] += ltq
            else:
                # if between bid/ask, still record half/half
                self.levels[ltp]["bid"] += ltq // 2
                self.levels[ltp]["ask"] += ltq // 2
        else:
            # no bidAsk, still record volume in ask side
            self.levels[ltp]["ask"] += ltq

        now = int(time.time())
        if now - self.start_ts >= FOOTPRINT_TF_SEC:
            levels_str = {str(k): v for k, v in self.levels.items()}

            doc = {
                "type": "footprint",
                "symbol": self.symbol,
                "ts": self.start_ts,
                "levels": levels_str,
                "created_at": datetime.utcnow()
            }


            await fp_col.insert_one(doc)
            await broadcast(doc)
            self.reset()

    # async def emit_footprint(self):
    #     # convert levels to string keys
    #     levels_str = {str(k): v for k, v in self.levels.items()}

    #     doc = {
    #         "type": "footprint",
    #         "symbol": self.symbol,
    #         "ts": self.start_ts,
    #         "levels": levels_str,
    #         "created_at": datetime.utcnow()
    #     }

    #     await fp_col.insert_one(doc)
    #     await broadcast(doc)

# =====================================================
# DOM ENGINE
# =====================================================

class DOMEngine:
    def __init__(self, symbol: str):
        self.symbol = symbol

    async def on_snapshot(self, bidask: list):
        if not bidask:
            return
        bids = {}
        asks = {}

        for l in bidask:
            if "bidP" in l and "bidQ" in l:
                bids[str(l["bidP"])] = int(l["bidQ"])

            if "askP" in l and "askQ" in l:
                asks[str(l["askP"])] = int(l["askQ"])

        doc = {
            "symbol": self.symbol,
            "ts": int(time.time()),
            "bids": bids,
            "asks": asks
        }

        await dom_col.insert_one(doc)
        await broadcast({"type": "dom", **doc})

# =====================================================
# ROUTER
# =====================================================

class LiveMarketRouter:
    def __init__(self):
        self.fp = {}
        self.dom = {}

    def fp_engine(self, symbol):
        if symbol not in self.fp:
            self.fp[symbol] = FootprintEngine(symbol)
        return self.fp[symbol]

    def dom_engine(self, symbol):
        if symbol not in self.dom:
            self.dom[symbol] = DOMEngine(symbol)
        return self.dom[symbol]

    async def handle(self, msg):
        feeds = msg.get("feeds", {})
        for symbol, payload in feeds.items():

            ff = payload.get("fullFeed", {}).get("marketFF") \
                 or payload.get("fullFeed", {}).get("indexFF")
            if not ff:
                continue

            ltpc = ff.get("ltpc")
            if not ltpc:
                continue

            snap = {
                "symbol": symbol,
                "ltp": float(ltpc.get("ltp", 0)),
                "ltq": int(ltpc.get("ltq", 0)) if ltpc.get("ltq") else 0,
                "bidask": ff.get("marketLevel", {}).get("bidAskQuote", [])
            }

            await self.fp_engine(symbol).on_tick(snap)
            await self.dom_engine(symbol).on_snapshot(snap["bidask"])

router = LiveMarketRouter()

# =====================================================
# QUEUE CONSUMER (FASTAPI LOOP)
# =====================================================

@app.on_event("startup")
async def start_consumer():
    async def consume():
        while True:
            msg = await market_queue.get()
            await router.handle(msg)

    asyncio.create_task(consume())

# =====================================================
# FASTAPI ROUTES
# =====================================================

@app.websocket("/ws")
async def ws_ui(ws: WebSocket):
    await ws.accept()
    clients.add(ws)
    try:
        while True:
            await ws.receive_text()
    except:
        clients.discard(ws)

@app.get("/symbols")
async def symbols():
    syms = await fp_col.distinct("symbol")
    return JSONResponse(syms)

@app.get("/history/{symbol}")
async def history(symbol: str):
    out = []
    async for d in fp_col.find({"symbol": symbol, "type": "footprint"}).sort("ts", -1).limit(200):
        d["_id"] = str(d["_id"])
        # ensure string keys
        if "levels" in d:
            d["levels"] = {str(k): v for k,v in d["levels"].items()}
        out.append(d)
    return out[::-1]  # oldest first

# =====================================================
# STATIC UI
# =====================================================

app.mount("/ui", StaticFiles(directory="frontend", html=True), name="ui")

# =====================================================
# UPSTOX WSS (THREAD SAFE)
# =====================================================

def start_upstox():
    cfg = upstox_client.Configuration()
    cfg.access_token = ACCESS_TOKEN
    api = upstox_client.ApiClient(cfg)

    streamer = MarketDataStreamerV3(api, INSTRUMENTS, "full")

    streamer.on("message", lambda m: market_queue.put_nowait(
        json.loads(m) if isinstance(m, str) else m
    ))
    streamer.on("open", lambda: print("[WSS] Connected"))
    streamer.connect()

# =====================================================
# BOOT
# =====================================================

if __name__ == "__main__":
    threading.Thread(target=start_upstox, daemon=True).start()
    print(f"[SYSTEM] Running on port {PORT}")
    uvicorn.run(app, host="0.0.0.0", port=PORT)
